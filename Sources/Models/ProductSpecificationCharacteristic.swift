//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** A characteristic quality or distinctive feature of a ProductSpecification.  The characteristic can be take on a discrete value, such as color, can take on a range of values, (for example, sensitivity of 100-240 mV), or can be derived from a formula (for example, usage time (hrs) = 30 - talk time *3). Certain characteristics, such as color, may be configured during the ordering or some other process. */
public class ProductSpecificationCharacteristic: APIModel {

    /** When sub-classing, this defines the super-class */
    public var alphabaseType: String?

    /** A URI to a JSON-Schema file that defines additional attributes and relationships */
    public var alphaschemaLocation: URL?

    /** When sub-classing, this defines the sub-class Extensible name */
    public var alphatype: String?

    /** This (optional) field provides a link to the schema describing the value type. */
    public var alphavalueSchemaLocation: String?

    /** If true, the Boolean indicates that the target Characteristic is configurable */
    public var configurable: Bool?

    /** A narrative that explains the CharacteristicSpecification. */
    public var description: String?

    /** An indicator that specifies that the values for the characteristic can be extended by adding new values when instantiating a characteristic for a resource. */
    public var extensible: Bool?

    /** Unique ID for the characteristic */
    public var id: String?

    /** An indicator that specifies if a value is unique for the specification. Possible values are; "unique while value is in effect" and "unique whether value is in effect or not" */
    public var isUnique: Bool?

    /** The maximum number of instances a CharacteristicValue can take on. For example, zero to five phone numbers in a group calling plan, where five is the value for the maxCardinality. */
    public var maxCardinality: Int?

    /** The minimum number of instances a CharacteristicValue can take on. For example, zero to five phone numbers in a group calling plan, where zero is the value for the minCardinality. */
    public var minCardinality: Int?

    /** A word, term, or phrase by which this characteristic specification is known and distinguished from other characteristic specifications. */
    public var name: String?

    /** An aggregation, migration, substitution, dependency or exclusivity relationship between/among Specification Characteristics. */
    public var productSpecCharRelationship: [ProductSpecificationCharacteristicRelationship]?

    /** A ProductSpecificationCharacteristicValue object is used to define a set of attributes, each of which can be assigned to a corresponding set of attributes in a ProductSpecificationCharacteristic object. The values of the attributes in the ProductSpecificationCharacteristicValue object describe the values of the attributes that a corresponding ProductSpecificationCharacteristic object can take on. */
    public var productSpecCharacteristicValue: [CharacteristicValueSpecification]?

    /** A rule or principle represented in regular expression used to derive the value of a characteristic value. */
    public var regex: String?

    public var validFor: TimePeriod?

    /** A kind of value that the characteristic can take on, such as numeric, text and so forth */
    public var valueType: String?

    public init(alphabaseType: String? = nil, alphaschemaLocation: URL? = nil, alphatype: String? = nil, alphavalueSchemaLocation: String? = nil, configurable: Bool? = nil, description: String? = nil, extensible: Bool? = nil, id: String? = nil, isUnique: Bool? = nil, maxCardinality: Int? = nil, minCardinality: Int? = nil, name: String? = nil, productSpecCharRelationship: [ProductSpecificationCharacteristicRelationship]? = nil, productSpecCharacteristicValue: [CharacteristicValueSpecification]? = nil, regex: String? = nil, validFor: TimePeriod? = nil, valueType: String? = nil) {
        self.alphabaseType = alphabaseType
        self.alphaschemaLocation = alphaschemaLocation
        self.alphatype = alphatype
        self.alphavalueSchemaLocation = alphavalueSchemaLocation
        self.configurable = configurable
        self.description = description
        self.extensible = extensible
        self.id = id
        self.isUnique = isUnique
        self.maxCardinality = maxCardinality
        self.minCardinality = minCardinality
        self.name = name
        self.productSpecCharRelationship = productSpecCharRelationship
        self.productSpecCharacteristicValue = productSpecCharacteristicValue
        self.regex = regex
        self.validFor = validFor
        self.valueType = valueType
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        alphabaseType = try container.decodeIfPresent("@baseType")
        alphaschemaLocation = try container.decodeIfPresent("@schemaLocation")
        alphatype = try container.decodeIfPresent("@type")
        alphavalueSchemaLocation = try container.decodeIfPresent("@valueSchemaLocation")
        configurable = try container.decodeIfPresent("configurable")
        description = try container.decodeIfPresent("description")
        extensible = try container.decodeIfPresent("extensible")
        id = try container.decodeIfPresent("id")
        isUnique = try container.decodeIfPresent("isUnique")
        maxCardinality = try container.decodeIfPresent("maxCardinality")
        minCardinality = try container.decodeIfPresent("minCardinality")
        name = try container.decodeIfPresent("name")
        productSpecCharRelationship = try container.decodeArrayIfPresent("productSpecCharRelationship")
        productSpecCharacteristicValue = try container.decodeArrayIfPresent("productSpecCharacteristicValue")
        regex = try container.decodeIfPresent("regex")
        validFor = try container.decodeIfPresent("validFor")
        valueType = try container.decodeIfPresent("valueType")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(alphabaseType, forKey: "@baseType")
        try container.encodeIfPresent(alphaschemaLocation, forKey: "@schemaLocation")
        try container.encodeIfPresent(alphatype, forKey: "@type")
        try container.encodeIfPresent(alphavalueSchemaLocation, forKey: "@valueSchemaLocation")
        try container.encodeIfPresent(configurable, forKey: "configurable")
        try container.encodeIfPresent(description, forKey: "description")
        try container.encodeIfPresent(extensible, forKey: "extensible")
        try container.encodeIfPresent(id, forKey: "id")
        try container.encodeIfPresent(isUnique, forKey: "isUnique")
        try container.encodeIfPresent(maxCardinality, forKey: "maxCardinality")
        try container.encodeIfPresent(minCardinality, forKey: "minCardinality")
        try container.encodeIfPresent(name, forKey: "name")
        try container.encodeIfPresent(productSpecCharRelationship, forKey: "productSpecCharRelationship")
        try container.encodeIfPresent(productSpecCharacteristicValue, forKey: "productSpecCharacteristicValue")
        try container.encodeIfPresent(regex, forKey: "regex")
        try container.encodeIfPresent(validFor, forKey: "validFor")
        try container.encodeIfPresent(valueType, forKey: "valueType")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? ProductSpecificationCharacteristic else { return false }
      guard self.alphabaseType == object.alphabaseType else { return false }
      guard self.alphaschemaLocation == object.alphaschemaLocation else { return false }
      guard self.alphatype == object.alphatype else { return false }
      guard self.alphavalueSchemaLocation == object.alphavalueSchemaLocation else { return false }
      guard self.configurable == object.configurable else { return false }
      guard self.description == object.description else { return false }
      guard self.extensible == object.extensible else { return false }
      guard self.id == object.id else { return false }
      guard self.isUnique == object.isUnique else { return false }
      guard self.maxCardinality == object.maxCardinality else { return false }
      guard self.minCardinality == object.minCardinality else { return false }
      guard self.name == object.name else { return false }
      guard self.productSpecCharRelationship == object.productSpecCharRelationship else { return false }
      guard self.productSpecCharacteristicValue == object.productSpecCharacteristicValue else { return false }
      guard self.regex == object.regex else { return false }
      guard self.validFor == object.validFor else { return false }
      guard self.valueType == object.valueType else { return false }
      return true
    }

    public static func == (lhs: ProductSpecificationCharacteristic, rhs: ProductSpecificationCharacteristic) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
