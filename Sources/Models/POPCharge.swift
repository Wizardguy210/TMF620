//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** This is representing a product offering price (charge) based on both the basic cost to develop and produce products and the enterprises policy on revenue targets. This price may be further revised through discounting (a Product Offering Price that reflects an alteration). */
public class POPCharge: APIModel {

    /** When sub-classing, this defines the super-class */
    public var alphabaseType: String?

    /** A URI to a JSON-Schema file that defines additional attributes and relationships */
    public var alphaschemaLocation: URL?

    /** When sub-classing, this defines the sub-class Extensible name */
    public var alphatype: String?

    /** The Constraint resource represents a policy/rule applied to ProductOfferingPrice. */
    public var constraint: [ConstraintRef]?

    /** Description of the productOfferingPrice */
    public var description: String?

    /** Hyperlink reference */
    public var href: URL?

    /** unique identifier */
    public var id: String?

    /** the last update time of this ProductOfferingPrice */
    public var lastUpdate: DateTime?

    /** the lifecycle status of this ProductOfferingPrice */
    public var lifecycleStatus: String?

    /** Name of the productOfferingPrice */
    public var name: String?

    public var price: ProductPriceValue?

    public var priceAlteration: [POPAlteration]?

    /** A category that describes the price charge, such as recurring, penalty, One time fee and so forth. */
    public var priceType: String?

    /** The period type to repeat the application of the price
Could be month, week... */
    public var recurringChargePeriod: String?

    /** the period of the recurring charge:  1, 2, ... .It sets to zero if it is not applicable */
    public var recurringChargePeriodLength: Int?

    public var unitOfMeasure: Quantity?

    public var validFor: TimePeriod?

    /** ProductOffering version */
    public var version: String?

    public init(alphabaseType: String? = nil, alphaschemaLocation: URL? = nil, alphatype: String? = nil, constraint: [ConstraintRef]? = nil, description: String? = nil, href: URL? = nil, id: String? = nil, lastUpdate: DateTime? = nil, lifecycleStatus: String? = nil, name: String? = nil, price: ProductPriceValue? = nil, priceAlteration: [POPAlteration]? = nil, priceType: String? = nil, recurringChargePeriod: String? = nil, recurringChargePeriodLength: Int? = nil, unitOfMeasure: Quantity? = nil, validFor: TimePeriod? = nil, version: String? = nil) {
        self.alphabaseType = alphabaseType
        self.alphaschemaLocation = alphaschemaLocation
        self.alphatype = alphatype
        self.constraint = constraint
        self.description = description
        self.href = href
        self.id = id
        self.lastUpdate = lastUpdate
        self.lifecycleStatus = lifecycleStatus
        self.name = name
        self.price = price
        self.priceAlteration = priceAlteration
        self.priceType = priceType
        self.recurringChargePeriod = recurringChargePeriod
        self.recurringChargePeriodLength = recurringChargePeriodLength
        self.unitOfMeasure = unitOfMeasure
        self.validFor = validFor
        self.version = version
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        alphabaseType = try container.decodeIfPresent("@baseType")
        alphaschemaLocation = try container.decodeIfPresent("@schemaLocation")
        alphatype = try container.decodeIfPresent("@type")
        constraint = try container.decodeArrayIfPresent("constraint")
        description = try container.decodeIfPresent("description")
        href = try container.decodeIfPresent("href")
        id = try container.decodeIfPresent("id")
        lastUpdate = try container.decodeIfPresent("lastUpdate")
        lifecycleStatus = try container.decodeIfPresent("lifecycleStatus")
        name = try container.decodeIfPresent("name")
        price = try container.decodeIfPresent("price")
        priceAlteration = try container.decodeArrayIfPresent("priceAlteration")
        priceType = try container.decodeIfPresent("priceType")
        recurringChargePeriod = try container.decodeIfPresent("recurringChargePeriod")
        recurringChargePeriodLength = try container.decodeIfPresent("recurringChargePeriodLength")
        unitOfMeasure = try container.decodeIfPresent("unitOfMeasure")
        validFor = try container.decodeIfPresent("validFor")
        version = try container.decodeIfPresent("version")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(alphabaseType, forKey: "@baseType")
        try container.encodeIfPresent(alphaschemaLocation, forKey: "@schemaLocation")
        try container.encodeIfPresent(alphatype, forKey: "@type")
        try container.encodeIfPresent(constraint, forKey: "constraint")
        try container.encodeIfPresent(description, forKey: "description")
        try container.encodeIfPresent(href, forKey: "href")
        try container.encodeIfPresent(id, forKey: "id")
        try container.encodeIfPresent(lastUpdate, forKey: "lastUpdate")
        try container.encodeIfPresent(lifecycleStatus, forKey: "lifecycleStatus")
        try container.encodeIfPresent(name, forKey: "name")
        try container.encodeIfPresent(price, forKey: "price")
        try container.encodeIfPresent(priceAlteration, forKey: "priceAlteration")
        try container.encodeIfPresent(priceType, forKey: "priceType")
        try container.encodeIfPresent(recurringChargePeriod, forKey: "recurringChargePeriod")
        try container.encodeIfPresent(recurringChargePeriodLength, forKey: "recurringChargePeriodLength")
        try container.encodeIfPresent(unitOfMeasure, forKey: "unitOfMeasure")
        try container.encodeIfPresent(validFor, forKey: "validFor")
        try container.encodeIfPresent(version, forKey: "version")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? POPCharge else { return false }
      guard self.alphabaseType == object.alphabaseType else { return false }
      guard self.alphaschemaLocation == object.alphaschemaLocation else { return false }
      guard self.alphatype == object.alphatype else { return false }
      guard self.constraint == object.constraint else { return false }
      guard self.description == object.description else { return false }
      guard self.href == object.href else { return false }
      guard self.id == object.id else { return false }
      guard self.lastUpdate == object.lastUpdate else { return false }
      guard self.lifecycleStatus == object.lifecycleStatus else { return false }
      guard self.name == object.name else { return false }
      guard self.price == object.price else { return false }
      guard self.priceAlteration == object.priceAlteration else { return false }
      guard self.priceType == object.priceType else { return false }
      guard self.recurringChargePeriod == object.recurringChargePeriod else { return false }
      guard self.recurringChargePeriodLength == object.recurringChargePeriodLength else { return false }
      guard self.unitOfMeasure == object.unitOfMeasure else { return false }
      guard self.validFor == object.validFor else { return false }
      guard self.version == object.version else { return false }
      return true
    }

    public static func == (lhs: POPCharge, rhs: POPCharge) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
