//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** specification of a value (number or text or an object) that can be assigned to a Characteristic. */
public class CharacteristicValueSpecification: APIModel {

    /** When sub-classing, this defines the super-class */
    public var alphabaseType: String?

    /** A URI to a JSON-Schema file that defines additional attributes and relationships */
    public var alphaschemaLocation: URL?

    /** When sub-classing, this defines the sub-class Extensible name */
    public var alphatype: String?

    /** If true, the Boolean Indicates if the value is the default value for a characteristic */
    public var isDefault: Bool?

    /** An indicator that specifies the inclusion or exclusion of the valueFrom and valueTo attributes. If applicable, possible values are "open", "closed", "closedBottom" and "closedTop". */
    public var rangeInterval: String?

    /** A regular expression constraint for given value */
    public var regex: String?

    /** A length, surface, volume, dry measure, liquid measure, money, weight, time, and the like. In general, a determinate quantity or magnitude of the kind designated, taken as a standard of comparison for others of the same kind, in assigning to them numerical values, as 1 foot, 1 yard, 1 mile, 1 square foot. */
    public var unitOfMeasure: String?

    public var validFor: TimePeriod?

    public var value: `Any`?

    /** The low range value that a characteristic can take on */
    public var valueFrom: Int?

    /** The upper range value that a characteristic can take on */
    public var valueTo: Int?

    /** A kind of value that the characteristic value can take on, such as numeric, text and so forth */
    public var valueType: String?

    public init(alphabaseType: String? = nil, alphaschemaLocation: URL? = nil, alphatype: String? = nil, isDefault: Bool? = nil, rangeInterval: String? = nil, regex: String? = nil, unitOfMeasure: String? = nil, validFor: TimePeriod? = nil, value: `Any`? = nil, valueFrom: Int? = nil, valueTo: Int? = nil, valueType: String? = nil) {
        self.alphabaseType = alphabaseType
        self.alphaschemaLocation = alphaschemaLocation
        self.alphatype = alphatype
        self.isDefault = isDefault
        self.rangeInterval = rangeInterval
        self.regex = regex
        self.unitOfMeasure = unitOfMeasure
        self.validFor = validFor
        self.value = value
        self.valueFrom = valueFrom
        self.valueTo = valueTo
        self.valueType = valueType
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        alphabaseType = try container.decodeIfPresent("@baseType")
        alphaschemaLocation = try container.decodeIfPresent("@schemaLocation")
        alphatype = try container.decodeIfPresent("@type")
        isDefault = try container.decodeIfPresent("isDefault")
        rangeInterval = try container.decodeIfPresent("rangeInterval")
        regex = try container.decodeIfPresent("regex")
        unitOfMeasure = try container.decodeIfPresent("unitOfMeasure")
        validFor = try container.decodeIfPresent("validFor")
        value = try container.decodeIfPresent("value")
        valueFrom = try container.decodeIfPresent("valueFrom")
        valueTo = try container.decodeIfPresent("valueTo")
        valueType = try container.decodeIfPresent("valueType")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(alphabaseType, forKey: "@baseType")
        try container.encodeIfPresent(alphaschemaLocation, forKey: "@schemaLocation")
        try container.encodeIfPresent(alphatype, forKey: "@type")
        try container.encodeIfPresent(isDefault, forKey: "isDefault")
        try container.encodeIfPresent(rangeInterval, forKey: "rangeInterval")
        try container.encodeIfPresent(regex, forKey: "regex")
        try container.encodeIfPresent(unitOfMeasure, forKey: "unitOfMeasure")
        try container.encodeIfPresent(validFor, forKey: "validFor")
        try container.encodeIfPresent(value, forKey: "value")
        try container.encodeIfPresent(valueFrom, forKey: "valueFrom")
        try container.encodeIfPresent(valueTo, forKey: "valueTo")
        try container.encodeIfPresent(valueType, forKey: "valueType")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? CharacteristicValueSpecification else { return false }
      guard self.alphabaseType == object.alphabaseType else { return false }
      guard self.alphaschemaLocation == object.alphaschemaLocation else { return false }
      guard self.alphatype == object.alphatype else { return false }
      guard self.isDefault == object.isDefault else { return false }
      guard self.rangeInterval == object.rangeInterval else { return false }
      guard self.regex == object.regex else { return false }
      guard self.unitOfMeasure == object.unitOfMeasure else { return false }
      guard self.validFor == object.validFor else { return false }
      guard self.value == object.value else { return false }
      guard self.valueFrom == object.valueFrom else { return false }
      guard self.valueTo == object.valueTo else { return false }
      guard self.valueType == object.valueType else { return false }
      return true
    }

    public static func == (lhs: CharacteristicValueSpecification, rhs: CharacteristicValueSpecification) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
