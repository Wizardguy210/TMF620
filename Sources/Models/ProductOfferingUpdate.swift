//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** Represents entities that are orderable from the provider of the catalog, this resource includes pricing information.
Skipped properties: id,href,lastUpdate,@type,@baseType */
public class ProductOfferingUpdate: APIModel {

    /** A URI to a JSON-Schema file that defines additional attributes and relationships */
    public var alphaschemaLocation: URL?

    /** An agreement represents a contract or arrangement, either written or verbal and sometimes enforceable by law, such as a service level agreement or a customer price agreement. An agreement involves a number of other business entities, such as products, services, and resources and/or their specifications. */
    public var agreement: [AgreementRef]?

    /** Complements the description of an element (for instance a product) through video, pictures... */
    public var attachment: [AttachmentRefOrValue]?

    /** A type of ProductOffering that belongs to a grouping of ProductOfferings made available to the market. It inherits of all attributes of ProductOffering. */
    public var bundledProductOffering: [BundledProductOffering]?

    /** The category resource is used to group product offerings, service and resource candidates in logical containers. Categories can contain other categories and/or product offerings, resource or service candidates. */
    public var category: [CategoryRef]?

    /** The channel defines the channel for selling product offerings. */
    public var channel: [ChannelRef]?

    /** Description of the productOffering */
    public var description: String?

    /** isBundle determines whether a productOffering represents a single productOffering (false), or a bundle of productOfferings (true). */
    public var isBundle: Bool?

    /** A flag indicating if this product offer can be sold stand-alone for sale or not. If this flag is false it indicates that the offer can only be sold within a bundle. */
    public var isSellable: Bool?

    /** Used to indicate the current lifecycle status */
    public var lifecycleStatus: String?

    /** provides references to the corresponding market segment as target of product offerings. A market segment is grouping of Parties, GeographicAreas, SalesChannels, and so forth. */
    public var marketSegment: [MarketSegmentRef]?

    /** Name of the productOffering */
    public var name: String?

    /** Place defines the places where the products are sold or delivered. */
    public var place: [PlaceRef]?

    /** A use of the ProductSpecificationCharacteristicValue by a ProductOffering to which additional properties (attributes) apply or override the properties of similar properties contained in ProductSpecificationCharacteristicValue. It should be noted that characteristics which their value(s) addressed by this object must exist in corresponding product specification. The available characteristic values for a ProductSpecificationCharacteristic in a Product specification can be modified at the ProductOffering level. For example, a characteristic 'Color' might have values White, Blue, Green, and Red. But, the list of values can be restricted to e.g. White and Blue in an associated product offering. It should be noted that the list of values in 'ProductSpecificationCharacteristicValueUse' is a strict subset of the list of values as defined in the corresponding product specification characteristics. */
    public var prodSpecCharValueUse: [ProductSpecificationCharacteristicValueUse]?

    /** An amount, usually of money, that is asked for or allowed when a ProductOffering is bought, rented, or leased. The price is valid for a defined period of time and may not represent the actual price paid by a customer. */
    public var productOfferingPrice: [ProductOfferingPriceRefOrValue]?

    /** A relationship between this product offering and other product offerings. */
    public var productOfferingRelationship: [ProductOfferingRelationship]?

    /** A condition under which a ProductOffering is made available to Customers. For instance, a productOffering can be offered with multiple commitment periods. */
    public var productOfferingTerm: [ProductOfferingTerm]?

    public var productSpecification: ProductSpecificationRef?

    public var resourceCandidate: ResourceCandidateRef?

    public var serviceCandidate: ServiceCandidateRef?

    public var serviceLevelAgreement: SLARef?

    /** A string providing a complementary information on the value of the lifecycle status attribute. */
    public var statusReason: String?

    public var validFor: TimePeriod?

    /** ProductOffering version */
    public var version: String?

    public init(alphaschemaLocation: URL? = nil, agreement: [AgreementRef]? = nil, attachment: [AttachmentRefOrValue]? = nil, bundledProductOffering: [BundledProductOffering]? = nil, category: [CategoryRef]? = nil, channel: [ChannelRef]? = nil, description: String? = nil, isBundle: Bool? = nil, isSellable: Bool? = nil, lifecycleStatus: String? = nil, marketSegment: [MarketSegmentRef]? = nil, name: String? = nil, place: [PlaceRef]? = nil, prodSpecCharValueUse: [ProductSpecificationCharacteristicValueUse]? = nil, productOfferingPrice: [ProductOfferingPriceRefOrValue]? = nil, productOfferingRelationship: [ProductOfferingRelationship]? = nil, productOfferingTerm: [ProductOfferingTerm]? = nil, productSpecification: ProductSpecificationRef? = nil, resourceCandidate: ResourceCandidateRef? = nil, serviceCandidate: ServiceCandidateRef? = nil, serviceLevelAgreement: SLARef? = nil, statusReason: String? = nil, validFor: TimePeriod? = nil, version: String? = nil) {
        self.alphaschemaLocation = alphaschemaLocation
        self.agreement = agreement
        self.attachment = attachment
        self.bundledProductOffering = bundledProductOffering
        self.category = category
        self.channel = channel
        self.description = description
        self.isBundle = isBundle
        self.isSellable = isSellable
        self.lifecycleStatus = lifecycleStatus
        self.marketSegment = marketSegment
        self.name = name
        self.place = place
        self.prodSpecCharValueUse = prodSpecCharValueUse
        self.productOfferingPrice = productOfferingPrice
        self.productOfferingRelationship = productOfferingRelationship
        self.productOfferingTerm = productOfferingTerm
        self.productSpecification = productSpecification
        self.resourceCandidate = resourceCandidate
        self.serviceCandidate = serviceCandidate
        self.serviceLevelAgreement = serviceLevelAgreement
        self.statusReason = statusReason
        self.validFor = validFor
        self.version = version
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        alphaschemaLocation = try container.decodeIfPresent("@schemaLocation")
        agreement = try container.decodeArrayIfPresent("agreement")
        attachment = try container.decodeArrayIfPresent("attachment")
        bundledProductOffering = try container.decodeArrayIfPresent("bundledProductOffering")
        category = try container.decodeArrayIfPresent("category")
        channel = try container.decodeArrayIfPresent("channel")
        description = try container.decodeIfPresent("description")
        isBundle = try container.decodeIfPresent("isBundle")
        isSellable = try container.decodeIfPresent("isSellable")
        lifecycleStatus = try container.decodeIfPresent("lifecycleStatus")
        marketSegment = try container.decodeArrayIfPresent("marketSegment")
        name = try container.decodeIfPresent("name")
        place = try container.decodeArrayIfPresent("place")
        prodSpecCharValueUse = try container.decodeArrayIfPresent("prodSpecCharValueUse")
        productOfferingPrice = try container.decodeArrayIfPresent("productOfferingPrice")
        productOfferingRelationship = try container.decodeArrayIfPresent("productOfferingRelationship")
        productOfferingTerm = try container.decodeArrayIfPresent("productOfferingTerm")
        productSpecification = try container.decodeIfPresent("productSpecification")
        resourceCandidate = try container.decodeIfPresent("resourceCandidate")
        serviceCandidate = try container.decodeIfPresent("serviceCandidate")
        serviceLevelAgreement = try container.decodeIfPresent("serviceLevelAgreement")
        statusReason = try container.decodeIfPresent("statusReason")
        validFor = try container.decodeIfPresent("validFor")
        version = try container.decodeIfPresent("version")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(alphaschemaLocation, forKey: "@schemaLocation")
        try container.encodeIfPresent(agreement, forKey: "agreement")
        try container.encodeIfPresent(attachment, forKey: "attachment")
        try container.encodeIfPresent(bundledProductOffering, forKey: "bundledProductOffering")
        try container.encodeIfPresent(category, forKey: "category")
        try container.encodeIfPresent(channel, forKey: "channel")
        try container.encodeIfPresent(description, forKey: "description")
        try container.encodeIfPresent(isBundle, forKey: "isBundle")
        try container.encodeIfPresent(isSellable, forKey: "isSellable")
        try container.encodeIfPresent(lifecycleStatus, forKey: "lifecycleStatus")
        try container.encodeIfPresent(marketSegment, forKey: "marketSegment")
        try container.encodeIfPresent(name, forKey: "name")
        try container.encodeIfPresent(place, forKey: "place")
        try container.encodeIfPresent(prodSpecCharValueUse, forKey: "prodSpecCharValueUse")
        try container.encodeIfPresent(productOfferingPrice, forKey: "productOfferingPrice")
        try container.encodeIfPresent(productOfferingRelationship, forKey: "productOfferingRelationship")
        try container.encodeIfPresent(productOfferingTerm, forKey: "productOfferingTerm")
        try container.encodeIfPresent(productSpecification, forKey: "productSpecification")
        try container.encodeIfPresent(resourceCandidate, forKey: "resourceCandidate")
        try container.encodeIfPresent(serviceCandidate, forKey: "serviceCandidate")
        try container.encodeIfPresent(serviceLevelAgreement, forKey: "serviceLevelAgreement")
        try container.encodeIfPresent(statusReason, forKey: "statusReason")
        try container.encodeIfPresent(validFor, forKey: "validFor")
        try container.encodeIfPresent(version, forKey: "version")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? ProductOfferingUpdate else { return false }
      guard self.alphaschemaLocation == object.alphaschemaLocation else { return false }
      guard self.agreement == object.agreement else { return false }
      guard self.attachment == object.attachment else { return false }
      guard self.bundledProductOffering == object.bundledProductOffering else { return false }
      guard self.category == object.category else { return false }
      guard self.channel == object.channel else { return false }
      guard self.description == object.description else { return false }
      guard self.isBundle == object.isBundle else { return false }
      guard self.isSellable == object.isSellable else { return false }
      guard self.lifecycleStatus == object.lifecycleStatus else { return false }
      guard self.marketSegment == object.marketSegment else { return false }
      guard self.name == object.name else { return false }
      guard self.place == object.place else { return false }
      guard self.prodSpecCharValueUse == object.prodSpecCharValueUse else { return false }
      guard self.productOfferingPrice == object.productOfferingPrice else { return false }
      guard self.productOfferingRelationship == object.productOfferingRelationship else { return false }
      guard self.productOfferingTerm == object.productOfferingTerm else { return false }
      guard self.productSpecification == object.productSpecification else { return false }
      guard self.resourceCandidate == object.resourceCandidate else { return false }
      guard self.serviceCandidate == object.serviceCandidate else { return false }
      guard self.serviceLevelAgreement == object.serviceLevelAgreement else { return false }
      guard self.statusReason == object.statusReason else { return false }
      guard self.validFor == object.validFor else { return false }
      guard self.version == object.version else { return false }
      return true
    }

    public static func == (lhs: ProductOfferingUpdate, rhs: ProductOfferingUpdate) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
